// Trong component ProductDetail
[Parameter]
public EventCallback<Product> OnProductAdded { get; set; }

public void AddProduct(Product product)
{
    OrderState.AddProductToOrder(product);
    OnProductAdded.InvokeAsync(product);
}

// Trong component Cart
<ProductDetail OnProductAdded="UpdateCart" />

@code {
    private void UpdateCart(Product product)
    {
        StateHasChanged();
    }
}

Triến khai Interface service. Tính trừu tượng và đa hình

Khi nào dùng gọi ra interface của đối tượng đó và gọi function của chúng


State managment : https://kaushikroychowdhury.com/blog/mastering-state-management-in-blazor-a-comprehensive-guide/
Quản lý state bằng cách inmemory container


Migration:
tải package dotnet ef
tải core design
dotnet ef database update
Server=DESKTOP-D4CG3NQ;Database=Mango_Order;Trusted_Connection=SSPI;Encrypt=false;TrustServerCertificate=true

Dùng cái này : 
Server=localhost;Database=TodoData;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=True

CloudDB:
Server=tcp:tgddcloneserver.database.windows.net,1433;Initial Catalog=TGDD;Persist Security Info=False;User ID=haohan2801;Password=Benten2001;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;

Gắn thêm sau Database: để đăng nhập User Id=myUsername;Password=myPassword;

Server=(localdb)\\mssqllocaldb;Database=TGDD;Trusted_Connection=SSPI;Encrypt=false;TrustServerCertificate=true

Tại sao lại tạo ra lớp DTO ?
ko return toàn bộ object. return dto (data transfer object)
model dto y chang như model bình thường
Thông qua mapper để nối giữa model và dto
Giảm số lần gọi đến api

Mapper ở giữa : automapper, automapper dependency injection
jwtBearer : secure api


//////////////TẠO DATABASE MIGRATION//////////////////
Tạo folder Data trong đó chứa file DbContext.cs
-> Tạo constructor để khởi tạo các bảng truyền vào cấu hình khởi tạo
public DBContext(DbContextOptions<DBContext> options) : base(options) { }
Tạo DbContext để tạo migration

Gắn service DbContext sqlserver vào program

builder.Services.AddDbContext<DBContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));


"ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Database=TGDD;Integrated Security=True;Trusted_Connection=True;TrustServerCertificate=True"
  },

nuget terminal
câu lênh trong coretool
add-migration CreateDBTGDD (tên migration)
update-database 

Database First:

Scaffold-DbContext 'điềnconnectionstring' Microsoft.EntityFrameworkCore.SqlServer -ContextDir Data -OutputDir Data

//Thêm vào để gắn identity security
//Truyền data vào trong method này lúc sau comment lại
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
	base.OnModelCreating(modelBuilder);

// truyền data ở đây, chạy xong comment lại
	 modelBuilder.Entity<Coupon>().HasData(new Coupon
            {
               CouponId = 1,
               CouponCode = "10OFF",
               DiscountAmount = 10,
               MinAmount = 20
            });

	modelBuilder.Entity<Coupon>().HasData(new Coupon
            {
               CouponId = 1,
               CouponCode = "10OFF",
               DiscountAmount = 10,
               MinAmount = 20
            });
}

   
update-database


Design Pattern chia làm 3 nhóm :
- Nhóm khởi tạo (Creational): Singleton, FactoryMethod, Builder
- Nhóm cấu trúc (Structural): Liên quan đến tổ chức các lớp đối tượng : Adapter, Repository(Giúp cho truy cập dữ liệu chặt chẽ và bảo mật hơn)
Repository là lớp trung gian giữa tầng business logic và data access. Giúp tách biệt phần mềm giảm sự phụ thuộc

=> Cách mình đang xài là repository design pattern
Tạo 1 interface để định nghĩa các phương thức truy cập dữ liệu chung
Tạo 1 class để cài đặt interface đó
Interface này có thể được inject vào controller hoặc service thông qua dependency injection


- Nhóm hành vi (Behavioral): Liên quan đến giao tiếp phân công trách nhiệm giữa các đối tượng


Clean Architecture .net

Domain: Trung tâm của architecture, định nghĩa entities, aggregates, reppository interface
Infrastucture: triển khai query csdl, lưu trữ, message queue
Presentation: Web ui
Test: kiểm tra 

https://www.ezzylearning.net/tutorial/building-blazor-server-apps-with-clean-architecture

Core
 -Application 
 -Domain (chứa khai báo entities,aggregate(1 hoặc nhiều đối tượng trong đó có 1 đối tượng là root) bên ngoài chỉ có thể truy cập vào root này
	-Common(contain base class and interface)
	-Entities
 -Application Layer: Là cầu nối trung gian giữa Domain và Presentation Layer bên ngoài.
			chứa Business service như DTO,Command, Queries
Infrastructure
Định nghĩa ra connection đến database,api. Giao tiếp với tầng Domain thông qua Appication. Không chứa logic nào
Có thể dễ dàng thay thế database mà ko bị ảnh hưởng

Presentation

https://www.c-sharpcorner.com/article/modern-architecture-shop/

https://stackoverflow.com/questions/61684831/guidance-for-blazor-server-with-api-gateway-and-microservices

Repository Pattern
Định nghĩa ra interface chứa các chức năng chung
Triển khai interface đó theo từng Class

Kế thừa từ interface ko cần phải là abstract class
Đa kế thừa : Abstract class kế thừa interface


FrontEnd phải có ModelDTO để lấy ra

=> Trong interface service định nghĩa ra các task

Task: Do việc lấy dữ liệu từ database mất 1 khoảng thời gian.
Do đó để ko bị khóa, chờ cho database lấy xong mà trong lúc lấy ta vẫn muốn làm những công việc khác để hiện thị giao diện
=> Dùng Task (chạy bất đồng bộ và trả về value)

Class implement interface service
Dùng httpClient để GetAsync("linkapi")


api payment gateway test:
sb-xgv5x28766804@personal.example.com
=9+j*6H+

CQRS (Command Query Responsibility Segregation) là một pattern cho việc xử lý CRUD dữ liệu.
đó chia việc tương tác với dữ liệu thành 2 thành phần Command và Query.
 Hai thành phần này tách biệt và độc lập với nhau.

Query trả về data mà không làm thay đổi trạng thái của hệ thống
Command thay đổi trạng thái của hệ thống nhưng không trả về data



Blazor circuit: Khi người dùng tương tác với web duy trì 1 trạng thái kết nối dc gọi là circuit
Trong webserver (statefull giữa client và server)

Mỗi circuit lưu trữ trạng thái 1 phiên làm việc giữa client và server. 
Circuit lưu thông tin trạng thái component, đầu ra render gần nhất , và các event ui

ssr : tạo ra trang web render hoàn chỉnh, gửi html đến browser
      Nhưng các component ko thể tương tác được sau lần render đầu , mọi giao tiếp với server cần thông qua http

https://community.devexpress.com/blogs/aspnet/archive/2023/12/13/blazor-new-net-8-render-modes-v23-2.aspx

Interactive Server Render Mode
-Chạy trên server, cập nhật UI thông qua SignalR => các sự kiện như onclick, gửi form sẽ dc gửi về server xử lý và cập nhật ui tương ứng
Interactive WebAssembly
Chạy ở phía người dùng, render phía client, hỗ trợ offline, độ trễ server là vấn đề

Server rendering có thể cung cấp thời gian tải ban đầu nhanh chóng 
và thường dễ dàng triển khai và lưu trữ hơn, 
nhưng yêu cầu một kết nối server hoạt động và có thể có độ trễ cao hơn do việc chuyển đổi mạng.

WebAssembly rendering cung cấp tương tác hoàn toàn ở phía client và hoạt động ngoại tuyến, 
nhưng có thể có thời gian tải ban đầu lớn

SignalR truyền tải giao tiếp client và server thông qua websocket hoặc phương thức khác nếu websocket ko khả dụng

CartItem DTO thì hiển thị ra giao diện, tính toán các thuộc tính như tổng tiền, giảm giá, dữ liệu tổng hợp ...


WorkFlow:
Method Get: 
Oninitial : ProductService -> GetItems -> method GetAsync return response-> (xử lý method Get thông qua controller API)

	    -> Trong Controller Get list item bằng repository -> Mapper sang DTO để tính toán trả lại thông tin cần cho giao diện


ReadFromJsonAsync  deserilization -> json to object
PostAsJsonAsync serialization -> object to json


Log trong Blazor:

@inject ILogger<ProductDetail> Logger
@inject JSRuntime JS

Tại sao lại phải dùng sate management. 
Khi nào nên dùng trong Blazor. Dữ liệu nào thì nên lưu trong State. 
Dữ liệu có trong database rồi có nên dùng trong state luôn ko ?

Dữ Liệu Giỏ Hàng: Thông thường, dữ liệu về các mặt hàng trong giỏ được lưu trữ trong trạng thái. Điều này cho phép trải nghiệm người dùng động và nhanh chóng, giúp người dùng thấy sự cập nhật tức thì của giỏ hàng khi họ chọn sản phẩm.

Thông Tin Phiên Người Dùng: Bao gồm sở thích người dùng, trạng thái đăng nhập và các dữ liệu khác liên quan đến phiên làm việc cần truy cập xuyên suốt ứng dụng.

Trạng Thái Giao Diện Người Dùng: Các trạng thái như bật/tắt bộ lọc, trạng thái của modal, hoặc lựa chọn trong dropdown có thể được quản lý bằng state.

Cache Dữ Liệu Sản Phẩm: Dữ liệu thường xuyên truy cập như danh sách sản phẩm, giá cả và mô tả có thể được lưu trong cache để giảm thiểu yêu cầu đến server.


Clean Architecture discuss: 
https://www.reddit.com/r/dotnet/comments/17hkg83/im_new_in_clean_architecture_domain_application/



statemanagement trong cart bằng localstorage

IEnumrable -> dùng khi chỉ cần lặp qua hết tất cả, Read Only data, Benefit for large dataset because not require dataset to load fully, ko cần Index

Sent Event delegate đã thông báo là state đã có sự thay đổi hãy cập nhật lại đi

update -> CartId, Cart


Secure API 


Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore
builder.Services.AddScoped<AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider>();

AddCascadingAuthenticationState  : child component can use Authentication state

builder.Services.AddScoped<IdentityUserAccessor>(); => Redirect user to successpage or to the protected page when success


builder.Services.AddScoped<IdentityRedirectManager>();=> Give access to the current user information to retrieve ID or data related
user after login, logout, etc.
4.	builder.Services.AddScoped<AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider>(); => Providing authen state


  "email": "tanghao@gmail.com",
  "password": "!Benten2001",
  "twoFactorCode": "string",
  "twoFactorRecoveryCode": "string"


ApplicationUser
IdentityUser

TGDD.Api.Data

StreamRendering: Cho phép component bắt đầu render và gửi content đến ngay khi có được dữ liệu
thay vì phải chờ toàn bộ component render xong rồi mới gửi data. cải thiện, giảm thời gian khởi tạo component

Large amount of data, long running operation


{
  "email": "test@example.com",
  "password": "!Benten2001",
  "confirmPassword": "!Benten2001"
}

ASP.NET Core Blazor authentication and authorization: https://learn.microsoft.com/en-us/aspnet/core/blazor/security/?view=aspnetcore-8.0

AuthenticationStateProvider service được dùng bởi AuthorizeView component và CascadingAuthenticationState


Authen and Author Principle : https://learn.microsoft.com/en-us/entra/fundamentals/identity-fundamental-concepts?toc=%2Fazure%2Fapp-service%2Ftoc.json&bc=%2Fazure%2Fapp-service%2Fbreadcrumb%2Ftoc.json


Scaffold Controller Api with Entitiesframework

- Sử dụng Log trong ứng dụng :
Ghi lại hoạt động dưới nền (background)
Phân tích lỗi
Theo dõi hiệu suất

=> Serilog.aspnetcore package
Serilog.Expressions => config appsetting.json
Serilog:

Mạnh mẽ trong việc định dạng log dưới dạng JSON, hữu ích cho việc xử lý log ở quy mô lớn và phân tích log.
Cung cấp "sinks" để gửi log đến nhiều đích khác nhau (file, cơ sở dữ liệu, dịch vụ đám mây).
Hỗ trợ "structured logging", cho phép ghi log với dữ liệu dạng cấu trúc, dễ dàng tìm kiếm và phân tích.

CORS(Corss-Origin-Resoure Sharing) là cơ chế cho phép frontend gửi request, communication đến backend
mà chúng được host trên những domain khác nhau



admin@gmail.com
!Admin123

ASP.NET Core Blazor authentication and authorization
https://learn.microsoft.com/en-us/aspnet/core/blazor/security/?view=aspnetcore-8.0

Secure ASP.NET Core server-side Blazor apps
https://learn.microsoft.com/en-us/aspnet/core/blazor/security/server/?view=aspnetcore-8.0&source=recommendations&tabs=visual-studio



https://github.com/PacktPublishing/ASP.NET-Core-API-and-Blazor-Development




https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master

// Must include [FromBody] in the parameter=> truyền parameter từ http gắn đúng tham số lấy từ body

GetCollection(int userID)

